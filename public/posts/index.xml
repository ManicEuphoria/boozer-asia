<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 亚洲豪饮者</title>
    <link>https://boozer.asia/posts/</link>
    <description>Recent content in Posts on 亚洲豪饮者</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 13 May 2025 18:21:25 +0800</lastBuildDate>
    <atom:link href="https://boozer.asia/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ruby参数传递与对象引用</title>
      <link>https://boozer.asia/posts/test/</link>
      <pubDate>Tue, 13 May 2025 18:21:25 +0800</pubDate>
      <guid>https://boozer.asia/posts/test/</guid>
      <description>&lt;p&gt;我们来举一个好玩的例子：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;modify_arr&lt;/span&gt;(b)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;b &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#x9;b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;modify_arr a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;puts a&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上的代码最终会打印出什么？&lt;/p&gt;&#xA;&lt;p&gt;大部分情况下，对ruby对象不熟悉的人，可能会说&lt;code&gt;[1, 2, 3]&lt;/code&gt;，但事实恰恰相反：结果是&lt;code&gt;[1, 2, 4]&lt;/code&gt;！&lt;/p&gt;&#xA;&lt;p&gt;为什么会出现这样的情况？其实当参数&lt;code&gt;arr&lt;/code&gt;被传递到函数中后，传递的仅仅是数组对象地址的引用，而非数组本身。但是在ruby中，对数组进行操作会修改数组对象本身，而赋值操作仅仅是将引用进行了新的对象创建，就算你在函数中返回了该引用，也是一个新的对象，而非原本的&lt;code&gt;a&lt;/code&gt;本身。&lt;/p&gt;&#xA;&lt;p&gt;以下时序图很好的反应了整个操作流程：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-mermaid&#34; data-lang=&#34;mermaid&#34;&gt;%% 参数传递全过程图解&#xA;sequenceDiagram&#xA;    participant Caller&#xA;    participant Method&#xA;    participant Heap&#xA;&#xA;    Note over Caller,Heap: 初始状态&#xA;    Caller-&amp;gt;&amp;gt;Heap: original → [1,2]&#xA;    &#xA;    Note over Caller,Heap: 调用方法时（传递引用副本）&#xA;    Caller-&amp;gt;&amp;gt;Method: 传递arr的引用副本&#xA;    Method-&amp;gt;&amp;gt;Heap: arr副本 → [1,2]&#xA;    &#xA;    Note over Method,Heap: 修改对象状态（影响原数据）&#xA;    Method-&amp;gt;&amp;gt;Heap: arr &amp;lt;&amp;lt; 4&#xA;    Heap--&amp;gt;&amp;gt;Method: [1,2,4]&#xA;    Heap--&amp;gt;&amp;gt;Caller: original同步变为[1,2,4]&#xA;&#xA;    Note over Method,Heap: 重新赋值（仅影响副本）&#xA;    Method-&amp;gt;&amp;gt;Heap: arr = [1,2,3]&#xA;    Heap--&amp;gt;&amp;gt;Method: 创建新对象&#xA;    Note over Caller: original仍为[1,2,4]&#xA;&#xA;    Note over Caller,Heap: 最终状态&#xA;    Caller-&amp;gt;&amp;gt;Heap: original → [1,2,4]&#xA;    Method-&amp;gt;&amp;gt;Heap: arr → [1,2,3]（独立新对象）&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然这是一个很好的例子，但是善于思考的人会提出一个问题：&lt;strong&gt;如果我在函数中返回了&lt;code&gt;b&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;还指向&lt;code&gt;a&lt;/code&gt;吗？&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
